package decide;

import static org.junit.jupiter.api.Assertions.assertEquals;

import org.junit.jupiter.api.Test;

public class PreliminaryUnlockingMatrixTest {
    // Shorthand for creating new point
    private Point p(double x, double y) {
        return new Point(x, y);
    }
    // Shorthands for the logical operators defined in Input.java
    private static final Input.LogicalOperator N = Input.LogicalOperator.NOT_USED;
    private static final Input.LogicalOperator A = Input.LogicalOperator.AND;
    private static final Input.LogicalOperator O = Input.LogicalOperator.OR;

    // Setup input for all true LIC conditions and run ConditionsMetVector(input), then setup a LCM and run 
    // PreliminaryUnlockingMatrix(input, cmv) lastly assert that the PUM's conditions are correct (ie all true 
    // since AND, OR or NOT_USED all equate to true for only true inputs).
    @Test
    void PUMassertsCorrectly() {
        Input input = new Input();

        // If adding lines, do *not* edit the already existing ones as this may cause others LICs to not evaluate true
        input.points = new Point[] {
                // LIC0
            p(0.45, -0.45), p(42, 4444), p(1.3, -0.45), p(1337, 420), p(Math.sqrt(3)/2, 1.5),   // LIC1, LIC8, LIC13
                // LIC2
                // LIC3
                // LIC4
                // LIC5...
            p(0, 0), p(69, 96), p(Math.sqrt(3), 0), p(123, 456), p(Math.sqrt(3)/2, 1.5),    // LIC13-continued
        };

        input.parameters = input.new Parameters();
        // LIC0

        // LIC1, LIC8, LIC13
        input.parameters.radius1 = 1;
        input.parameters.a_points = 1;
        input.parameters.b_points = 1;
        input.parameters.radius2 = 1;

        // LIC2 ...
        // .
        // .
        // .

        // Setup the ConditionsMetVector
        ConditionsMetVector cmv = new ConditionsMetVector(input);
        
        // Setup the symmetric Logical Connector Matrix, values are arbritrary (any A could equally well be O)
        input.lcm = new Input.LogicalOperator[][] {
            {A, O, O, A, A, N, A, A, O, A, A, A, O, O, N},
            {O, A, O, A, A, A, O, O, O, A, O, O, O, O, N},
            {O, O, A, A, N, A, O, A, O, O, A, A, A, A, N},
            {A, A, A, A, O, A, A, O, A, O, A, A, O, O, N},
            {A, A, N, O, A, O, O, A, A, A, O, A, O, N, N},
            {N, A, A, A, O, A, O, N, N, A, O, A, O, O, N},
            {A, O, O, A, O, O, A, A, O, N, A, N, N, N, N},
            {A, O, A, O, A, N, A, A, A, O, O, O, A, A, N},
            {O, O, O, A, A, N, O, A, A, A, O, O, N, O, N},
            {A, A, O, O, A, A, N, O, A, A, O, A, O, O, N},
            {A, O, A, A, O, O, A, O, O, O, A, N, A, O, N},
            {A, O, A, A, A, A, N, O, O, A, N, A, O, A, N},
            {O, O, A, O, O, O, N, A, N, O, A, O, A, A, N},
            {O, O, A, O, N, O, N, A, O, O, O, A, A, A, N},
            {N, N, N, N, N, N, N, N, N, N, N, N, N, N, A},
        };

        PreliminaryUnlockingMatrix pum = new PreliminaryUnlockingMatrix(input, cmv);

        // Check that the PUM's conditions are all true
        for (int row = 0; row < 15; row++) {
            for (int col = 0; col < 15; col++) {
                assertEquals(true, pum.conditions[row][col]);
            }
        }
    }
}
